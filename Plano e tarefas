ğŸ§© Projeto Final â€” Sistemas DistribuÃ­dos 2025/2026
SimulaÃ§Ã£o de TrÃ¡fego Urbano em Java (Processos + Threads + Sockets)

Ambiente: Windows 10/11 Â· IntelliJ IDEA Â· Maven Â· JSON Â· Scripts .bat Â· GitHub
Prazo final: 5 de dezembro de 2025

-------------------------------------------------------------------------

1ï¸âƒ£. Enquadramento TeÃ³rico

Objetivo geral:
Desenvolver um sistema distribuÃ­do em Java que simula o trÃ¡fego urbano de uma cidade, aplicando conceitos de comunicaÃ§Ã£o por sockets, sincronizaÃ§Ã£o entre threads, replicaÃ§Ã£o, polÃ­ticas adaptativas e consistÃªncia.

Base teÃ³rica:

FP1 â€“ IntroduÃ§Ã£o: sistemas distribuÃ­dos, comunicaÃ§Ã£o, escalabilidade;

FP2 â€“ Arquiteturas: cliente-servidor, camadas, comunicaÃ§Ã£o aberta;

FP3 â€“ Processos e Threads: criaÃ§Ã£o, sincronizaÃ§Ã£o e exclusÃ£o mÃºtua;

FP4 â€“ ComunicaÃ§Ã£o: Sockets TCP/UDP e serializaÃ§Ã£o JSON;

FP5 â€“ SincronizaÃ§Ã£o: relÃ³gios lÃ³gicos, Berkeley, Lamport, Ricart & Agrawala;

FP6 â€“ ReplicaÃ§Ã£o e ConsistÃªncia: modelos de atualizaÃ§Ã£o e consistÃªncia eventual;

FP7 â€“ RPC / Token Ring: eleiÃ§Ã£o, coordenaÃ§Ã£o e replicaÃ§Ã£o distribuÃ­da.

-------------------------------------------------------------------------

2ï¸âƒ£. Arquitetura Global
Estrutura em camadas
Camada	FunÃ§Ã£o	Exemplos de classes
AplicaÃ§Ã£o	LÃ³gica de trÃ¡fego, polÃ­ticas, dashboard	CoordinatorServer, CrossingProcess, PolicyManager
Transporte	ComunicaÃ§Ã£o entre processos	LinkIO, ClientHandler
Dados	Modelos e JSONs de configuraÃ§Ã£o	Vehicle, Event, Edge, ConfigLoader
Processos principais

CoordinatorServer â†’ Coordena a simulaÃ§Ã£o, polÃ­ticas e relÃ³gio.

CrossingProcess â†’ Gere cruzamentos, filas e semÃ¡foros.

DashboardHub â†’ Mostra estado e mÃ©tricas.

EntryGenerator â†’ Introduz veÃ­culos na rede.

SinkProcess â†’ Recolhe estatÃ­sticas de fim de percurso.

ComunicaÃ§Ã£o

TCP (bidirecional e confiÃ¡vel).

Mensagens JSON:

{ "type": "Telemetry", "payload": { "crossing": "Cr1", "queue": 3, "avg": 2.5 } }


SerializaÃ§Ã£o via Gson; codificaÃ§Ã£o UTF-8.

3ï¸âƒ£. Guia de Desenvolvimento (Fases 0â€“10)


-------------------------------------------------------------------------

ğŸ§± Fase 0 â€” Alicerces e Contratos

Objetivo: Base comum de dados, mensagens e ficheiros de configuraÃ§Ã£o.
ReferÃªncia: FP2 (Arquiteturas) + FP4 (Mensagens e JSON)

ğŸ”¹ Membro A

Criar pacote sd.traffic.common:

Message, Vehicle, NodeId, Edge, Event

Definir convenÃ§Ãµes de mensagens JSON (Telemetry, VehicleTransfer, PolicyUpdate).

Criar policy_hybrid.json com parÃ¢metros min/max/quotas.

ğŸ”¹ Membro B

Criar estrutura Maven e diretÃ³rios padrÃ£o (src/main/java, src/main/resources).

Implementar ConfigLoader e SimClock.

Criar routes.json e default_config.json.

Testar parsing de JSON (Gson).

ğŸ”¹ Contrato Aâ†”B

JSON base comum com "type" e "payload", UTF-8.
Portas base: 5000 + idProcesso.

ğŸ”¹ AceitaÃ§Ã£o

âœ… mvn clean package sem erros.
âœ… Todos os ficheiros JSON lidos corretamente.

-------------------------------------------------------------------------

ğŸ§  Fase 1 â€” Coordinator e DashboardHub

Objetivo: ComunicaÃ§Ã£o TCP base e centralizaÃ§Ã£o de controlo.
ReferÃªncia: FP4 (Sockets TCP)

ğŸ”¹ Membro A

Implementar CoordinatorServer, ClientHandler, EventLogStore, PolicyManager.

Suportar mensagens:

REGISTER â†’ registar cruzamento.

POLICY_UPDATE â†’ responder com polÃ­tica atual.

EVENT_LOG â†’ registar eventos.

TELEMETRY â†’ imprimir mÃ©tricas e guardar logs.

Gerar events.json com logs.

ğŸ”¹ Membro B

Implementar DashboardHub (TCP Server) para receber e imprimir mÃ©tricas.

Exibir texto em consola (textual agora, Swing nas fases posteriores).

Script: start_dashboard.bat.

ğŸ”¹ Contrato Aâ†”B
{"type": "Telemetry", "crossing": "Cr1", "queue": 4, "avg": 2.5, "lightState": "GREEN"}

ğŸ”¹ AceitaÃ§Ã£o

âœ… Crossings podem registar-se.
âœ… Dashboard recebe e mostra heartbeat.

-------------------------------------------------------------------------

ğŸ”— Fase 2 â€” Crossings e ComunicaÃ§Ã£o TCP

Objetivo: Interligar cruzamentos e simular passagem de veÃ­culos.
ReferÃªncia: FP4 (Sockets) + FP3 (Threads)

ğŸ”¹ Membro A

Criar LinkIO (canal TCP com retry e timeout).

Implementar broadcast de mensagens TELEMETRY recebidas para o DashboardHub (porta 5050).

Criar VehicleTransfer (estrutura de mensagem para passagem de veÃ­culos entre cruzamentos).

Gerir conexÃµes entre cruzamentos.

Manter logs centralizados em events.json.

Script: start_crossingX.bat.

ğŸ”¹ Membro B

Criar CrossingProcess (nÃ³ TCP individual de cada cruzamento):

Recebe veÃ­culo, espera t_sem (tempo de semÃ¡foro), reenvia para o prÃ³ximo.

Implementar ThreadPerConnection para gerir mÃºltiplas ligaÃ§Ãµes.

Log de transaÃ§Ãµes.

Script: start_crossingX.bat

ğŸ”¹ Contrato A â†” B (Crossing â†” Coordinator)

Mensagem de transferÃªncia de veÃ­culo:

{"vehicleId": "V123", "from": "Cr1", "to": "Cr2", "time": 110.0}

ğŸ”¹ CritÃ©rios de AceitaÃ§Ã£o (Fase 2)

âœ… Os Crossings ligam-se ao Coordinator e trocam mensagens sem erros.
âœ… O Coordinator recebe telemetria e difunde-a ao DashboardHub (broadcast).
âœ… O DashboardHub mostra em tempo real o estado dos cruzamentos.
âœ… Todos os sockets funcionam de forma concorrente, sem bloqueios TCP.


âš ï¸ Detalhes interessantes a adicionar:

Registo de dashboards
O Coordinator deve reconhecer quando um cliente Ã© o Dashboard (por ex., REGISTER com "role": "dashboard").
Assim, sabe para quem reenviar Telemetry.
ğŸ”¹ AtualizaÃ§Ã£o para fazer agora (Fase 2).

Mensagem de Heartbeat / Ping
Seria Ãºtil (para debug e estabilidade) cada CrossingProcess enviar um "HEARTBEAT" periÃ³dico.
O Coordinator pode registar a Ãºltima atualizaÃ§Ã£o de cada cruzamento.
ğŸ”¹ Opcional nesta fase, mas Ãºtil.

ConfiguraÃ§Ã£o de portas nos scripts
Os .bat devem comeÃ§ar a incluir parÃ¢metros (-Dexec.args) para poder iniciar mÃºltiplos cruzamentos com IDs distintos.
ğŸ”¹ Implementar agora (Fase 2).

Logs mais detalhados no EventLogStore
Registar nÃ£o sÃ³ Telemetry, mas tambÃ©m REGISTER e VehicleTransfer.
ğŸ”¹ Pequena melhoria para fazer agora.



ğŸ“˜ Resumo para ajudar a entender e estudar o projeto:

ğŸ”¹ 2.1. Classe LinkIO

Pacote: sd.traffic.common
ResponsÃ¡vel: Membro A
FunÃ§Ã£o principal: encapsular a comunicaÃ§Ã£o TCP entre processos, tornando o envio e a receÃ§Ã£o de mensagens simples, seguras e reutilizÃ¡veis.

âœ³ï¸ O que faz:

Cria e gere uma ligaÃ§Ã£o TCP (Socket) para um dado host e port;

Fornece mÃ©todos de alto nÃ­vel send() e receive() que trabalham diretamente com mensagens JSON;

Implementa reconexÃ£o automÃ¡tica (retry) em caso de falha de rede;

Define timeout para impedir bloqueios indefinidos na leitura;

Usa codificaÃ§Ã£o UTF-8 e serializaÃ§Ã£o via Gson, garantindo compatibilidade entre todos os processos.

âœ³ï¸ O que contÃ©m:

Atributos: Socket socket, PrintWriter out, BufferedReader in, String host, int port;

MÃ©todos:

connect() â€” abre o socket, configura streams e tenta ligaÃ§Ã£o com retry;

send(Object msg) â€” envia objetos jÃ¡ serializados em JSON;

receive() â€” bloqueia atÃ© receber uma linha JSON;

close() â€” encerra a ligaÃ§Ã£o de forma segura.

âœ³ï¸ IntegraÃ§Ã£o com fases anteriores:

LinkIO nÃ£o substitui diretamente o cÃ³digo interno do ClientHandler nem do DashboardHub (estes continuam a usar ServerSocket nesta fase),
mas estabelece a camada comum de comunicaÃ§Ã£o que serÃ¡ usada por processos clientes â€” nomeadamente CrossingProcess, EntryGenerator, e SinkProcess.

âœ³ï¸ RelaÃ§Ã£o futura:

Fases 3â€“5: garante comunicaÃ§Ã£o TCP fiÃ¡vel e ordenada entre cruzamentos;

Fases 6â€“7: servirÃ¡ de base para replicaÃ§Ã£o de polÃ­ticas e sincronizaÃ§Ã£o distribuÃ­da;

Fases 8â€“10: continuarÃ¡ a ser usado em todos os nÃ³s para simplificar a manutenÃ§Ã£o de ligaÃ§Ãµes.


ğŸ”¹ 2.2. Classe VehicleTransfer

Pacote: sd.traffic.coordinator.models
ResponsÃ¡vel: Membro A
FunÃ§Ã£o principal: representar a transferÃªncia de um veÃ­culo entre cruzamentos na rede.

âœ³ï¸ O que faz:

Define a estrutura padronizada da mensagem "VehicleTransfer";

Garante compatibilidade JSON entre Coordinator e Crossings;

Serve como payload para as mensagens de passagem de veÃ­culos.

âœ³ï¸ O que contÃ©m:

Atributos:

String vehicleId â€” identificador Ãºnico do veÃ­culo;

String from â€” cruzamento de origem;

String to â€” cruzamento de destino;

double time â€” instante ou duraÃ§Ã£o da travessia.

MÃ©todos: construtores, getters/setters e toString() para logging.

âœ³ï¸ IntegraÃ§Ã£o com fases anteriores:

Complementa a classe Vehicle (Fase 0), introduzindo a dimensÃ£o dinÃ¢mica do movimento.

Vehicle representa o veÃ­culo; VehicleTransfer representa a aÃ§Ã£o de deslocaÃ§Ã£o entre nÃ³s.

âœ³ï¸ RelaÃ§Ã£o futura:

Fase 4: usada pelos EntryGenerator para introduzir veÃ­culos na rede;

Fase 5: utilizada na comunicaÃ§Ã£o entre cruzamentos com controlo de tempo (SimClock);

Fase 7: integrada nos logs do SinkProcess para calcular tempos de percurso.


ğŸ”¹ 2.3. Classe CrossingProcess

Pacote: sd.traffic.crossing
ResponsÃ¡vel: Membro B
FunÃ§Ã£o principal: representar um cruzamento como um processo TCP independente que se liga ao Coordinator e envia dados periÃ³dicos de telemetria.

âœ³ï¸ O que faz:

Liga-se ao Coordinator usando LinkIO;

Envia mensagem REGISTER com o seu identificador;

Envia periodicamente mensagens Telemetry (nÃºmero de veÃ­culos, estado da luz, mÃ©dia de espera, etc.);

Pode enviar VehicleTransfer quando um veÃ­culo Ã© transferido para outro cruzamento;

Recebe POLICY_UPDATE e ajusta localmente os tempos de semÃ¡foro.

âœ³ï¸ O que contÃ©m:

Atributos: String id, LinkIO link, Policy localPolicy, Queue<Vehicle>;

MÃ©todos:

start() â€” inicia a ligaÃ§Ã£o e as threads internas;

sendRegister() â€” envia o REGISTER ao Coordinator;

sendTelemetry() â€” envia mÃ©tricas simuladas em intervalos regulares;

handleMessages() â€” escuta respostas e atualizaÃ§Ãµes do Coordinator.

âœ³ï¸ IntegraÃ§Ã£o com fases anteriores:

Usa Message e Gson (Fase 0) para serializaÃ§Ã£o;

LÃª parÃ¢metros (p. ex. tempos de semÃ¡foro) de default_config.json via ConfigLoader;

Liga-se ao CoordinatorServer (Fase 1) na porta 6000.

âœ³ï¸ RelaÃ§Ã£o futura:

Fase 3: adiciona threads internas (SemaphoreThread, QueueManager) para controlo de semÃ¡foros;

Fases 4â€“5: passa a movimentar veÃ­culos reais entre cruzamentos;

Fase 6: reage a POLICY_UPDATE;

Fase 7: envia estatÃ­sticas ao SinkProcess.


ğŸ”¹ 2.4. AtualizaÃ§Ã£o de CoordinatorServer

Pacote: sd.traffic.coordinator
ResponsÃ¡vel: Membro A
FunÃ§Ã£o adicional: retransmitir mensagens Telemetry recebidas dos Crossings para o DashboardHub.

âœ³ï¸ Novas responsabilidades:

Manter uma lista de dashboards ligados (Map<String, Socket>);

Implementar broadcastTelemetry(String telemetryJson) para enviar dados a todos os Dashboards registados;

Atualizar o ClientHandler para invocar esse broadcast sempre que recebe Telemetry.

âœ³ï¸ IntegraÃ§Ã£o com fases anteriores:

Reutiliza o sistema multi-thread de ClientHandler (Fase 1);

Continua a registar eventos no EventLogStore;

Passa a atuar como hub central de difusÃ£o de telemetria, recebendo de mÃºltiplos Crossings e reenviando ao DashboardHub.

âœ³ï¸ RelaÃ§Ã£o futura:

Fase 3: coordenarÃ¡ a sincronizaÃ§Ã£o dos tempos de semÃ¡foro;

Fase 5: funcionarÃ¡ como time daemon (Berkeley Clock);

Fase 6: gerirÃ¡ a replicaÃ§Ã£o e envio de POLICY_UPDATE.


ğŸ”¹ 2.5. Scripts de execuÃ§Ã£o

ResponsÃ¡veis: Membro A e Membro B

start_coordinator.bat â€” arranca o CoordinatorServer (6000);

start_dashboard.bat â€” arranca o DashboardHub (5050);

start_crossingX.bat â€” arranca um CrossingProcess especÃ­fico (ex.: Cr1).
-------------------------------------------------------------------------

ğŸš¦ Fase 3 â€” SemÃ¡foros e Filas

Objetivo: Introduzir sincronizaÃ§Ã£o e controlo de trÃ¡fego.
ReferÃªncia: FP3B (Threads) + FP5 (SincronizaÃ§Ã£o)

ğŸ”¹ Membro A

Criar PhaseController: controla alternÃ¢ncia entre fases (NS/EW).

Implementar exclusÃ£o mÃºtua (mutex global via Coordinator).

Introduzir relÃ³gio lÃ³gico (Lamport clock).

ğŸ”¹ Membro B

Implementar SemaphoreThread e QueueManager.

Cada cruzamento tem:

Thread por direÃ§Ã£o (N, S, E, O).

GestÃ£o de filas (ConcurrentLinkedQueue).

SincronizaÃ§Ã£o com wait() e notifyAll().

Garantir que apenas um sentido estÃ¡ verde.

ğŸ”¹ Contrato Aâ†”B
{"crossing": "Cr1", "semaphore": "N", "state": "GREEN", "queue": 3}

ğŸ”¹ AceitaÃ§Ã£o

âœ… MudanÃ§as de fase sem conflito.
âœ… Fila esvazia corretamente.

-------------------------------------------------------------------------

ğŸ›£ï¸ Fase 4 â€” EntryGenerators e Rotas

Objetivo: Introduzir veÃ­culos na rede com base em Î» (Poisson).
ReferÃªncia: FP4 (ComunicaÃ§Ã£o)

ğŸ”¹ Membro A

Criar EntryGeneratorProcess (thread que envia veÃ­culos periodicamente).

Ligar-se ao Coordinator.

Definir taxa Î» por entrada (E1â€“E3).

ğŸ”¹ Membro B

Criar RouteSelector: lÃª routes.json e define percursos probabilÃ­sticos.

Testar geraÃ§Ã£o paralela com threads independentes.

ğŸ”¹ Contrato Aâ†”B
{"entry": "E1", "vehicleType": "carro", "path": ["E1","Cr1","Cr4","Cr5","S"]}

ğŸ”¹ AceitaÃ§Ã£o

âœ… VeÃ­culos gerados segundo Î».
âœ… Percursos vÃ¡lidos e concluÃ­dos.

-------------------------------------------------------------------------

â±ï¸ Fase 5 â€” DeslocaÃ§Ã£o entre NÃ³s

Objetivo: Gerir tempo simulado e envio ordenado de mensagens.
ReferÃªncia: FP5 (Lamport e Berkeley)

ğŸ”¹ Membro A

Usar SimClock para relÃ³gio global.

Implementar Coordinator como time daemon (Berkeley).

Enviar SEND_TO_NEXT e agendar RECEIVE_FROM_PREV.

ğŸ”¹ Membro B

Receber veÃ­culos e colocÃ¡-los na fila local.

Confirmar atraso correto (t_road * factor).

ğŸ”¹ AceitaÃ§Ã£o

âœ… Tempo entre nÃ³s coerente.
âœ… Eventos ordenados (Lamport clock).

-------------------------------------------------------------------------

ğŸ§® Fase 6 â€” PolÃ­ticas Adaptativas

Objetivo: AdaptaÃ§Ã£o de tempos conforme trÃ¡fego.
ReferÃªncia: FP6 (ReplicaÃ§Ã£o e ConsistÃªncia)

ğŸ”¹ Membro A

PolicyManager â†’ primary replica.

Atualiza tempos verdes/vermelhos conforme filas.

Envia POLICY_UPDATE para cruzamentos.

ğŸ”¹ Membro B

Aplica polÃ­tica localmente e confirma ACK.

Implementa consistÃªncia eventual.

MantÃ©m Ãºltima polÃ­tica ativa em cache.

ğŸ”¹ AceitaÃ§Ã£o

âœ… PolÃ­ticas atualizam-se em tempo real.
âœ… Logs sincronizados.

-------------------------------------------------------------------------

ğŸ” Fase 7 â€” Sink e EstatÃ­sticas

Objetivo: Recolher resultados e calcular mÃ©tricas.
ReferÃªncia: FP6 (ConsistÃªncia eventual)

ğŸ”¹ Membro A

Criar SinkProcess (porta 6300).

Receber veÃ­culos concluÃ­dos e calcular tempos mÃ©dios.

ğŸ”¹ Membro B

Enviar mÃ©tricas periÃ³dicas ao Dashboard.

Criar metrics_summary.json.

ğŸ”¹ AceitaÃ§Ã£o

âœ… EstatÃ­sticas corretas e consistentes.

ğŸ§© Fase 7.5 â€” CoordenaÃ§Ã£o e ConsistÃªncia Replicada

Objetivo: Garantir continuidade apÃ³s falhas.
ReferÃªncia: FP7 (Token Ring, EleiÃ§Ã£o)

ğŸ”¹ Membro A

Implementar ElectionManager (Bully ou Token Ring).

Substituir CoordinatorServer em caso de falha.

ğŸ”¹ Membro B

Implementar ReplicaSync: sincroniza estado dos cruzamentos.

Reintegra cruzamentos desconectados.

ğŸ”¹ AceitaÃ§Ã£o

âœ… Sistema recupera apÃ³s falhas.
âœ… RÃ©plicas atualizadas.

-------------------------------------------------------------------------

ğŸ“Š Fase 8 â€” Dashboard Final

ReferÃªncia: FP2 (Camadas) + FP7 (RPC)

ğŸ”¹ Membro A

Criar API TCP no DashboardHub para histÃ³rico.

ğŸ”¹ Membro B

Interface JavaFX ou consola com mapa 3Ã—3 e grÃ¡ficos.

ExportaÃ§Ã£o CSV e refresh 2 Hz.

ğŸ”¹ AceitaÃ§Ã£o

âœ… AtualizaÃ§Ã£o contÃ­nua e exportaÃ§Ã£o funcional.

-------------------------------------------------------------------------


ğŸ”¬ Fase 9 â€” CenÃ¡rios e PolÃ­ticas

ReferÃªncia: FP1â€“FP6 (Experimentos distribuÃ­dos)

ğŸ”¹ Membro A

Criar ScenarioRunner (executa low/medium/high load).

ğŸ”¹ Membro B

Gerar grÃ¡ficos e scenario_results.json.

-------------------------------------------------------------------------


ğŸ§± Fase 10 â€” Testes e Entrega Final

Objetivo: Garantir estabilidade total e integraÃ§Ã£o completa.

ğŸ”¹ Membro A

Scripts .bat para todos os processos.

Testes de reconexÃ£o e timeouts.

ğŸ”¹ Membro B

Testes de stress e concorrÃªncia.

RelatÃ³rio final e mÃ©tricas.

-------------------------------------------------------------------------


ğŸ”§ Planeamento semanal 


| Semana            | Fases      | Membro A                  | Membro B                      | EntregÃ¡veis                 | Marco/Review           |
| ----------------- | ---------- | ------------------------- | ----------------------------- | --------------------------- | ---------------------- |
| **1 (28â€“1 nov)**  | Fase 0     | Modelos + JSON parsing    | Estrutura Maven + routes.json | Projeto compila             | Code Review JSON       |
| **2 (3â€“8 nov)**   | Fase 1     | Coordinator TCP           | DashboardHub                  | Heartbeats visÃ­veis         | Teste rede Aâ†”B         |
| **3 (10â€“15 nov)** | Fase 2     | LinkIO + sockets          | CrossingProcess               | VeÃ­culos dummy transferidos | IntegraÃ§Ã£o cruzamentos |
| **4 (17â€“22 nov)** | Fase 3     | PhaseController           | Semaphores + QueueManager     | Fases e filas funcionais    | Teste local E2E        |
| **5 (24â€“29 nov)** | Fases 4â€“5  | EntryGenerators + eventos | ReceÃ§Ã£o e deslocaÃ§Ã£o          | VeÃ­culos circulam           | Full path test         |
| **6 (1â€“5 dez)**   | Fases 6â€“10 | PolÃ­ticas + cenÃ¡rios      | Sink + dashboard + relatÃ³rio  | SimulaÃ§Ã£o completa          | RevisÃ£o final          |


âš™ï¸ Riscos e MitigaÃ§Ã£o

Risco	                           MitigaÃ§Ã£o
Falha de coordenador --------	EleiÃ§Ã£o distribuÃ­da
InconsistÃªncia -------- SincronizaÃ§Ã£o eventual
Bloqueios TCP --------	Timeouts e retry
Corridas ----------------	synchronized, wait/notify
DivergÃªncia de polÃ­tica --------	ConsistÃªncia sequencial


âœ… EntregÃ¡veis principais:

Tipo	Ficheiro	ResponsÃ¡vel
CÃ³digo	CoordinatorServer.java	A
CÃ³digo	CrossingProcess.java	B
CÃ³digo	PhaseController.java	A
CÃ³digo	SemaphoreThread.java	B
CÃ³digo	DashboardHub.java	B
Config	policy_*.json, default_config.json	A/B
Log	events.json, metrics_summary.json	A/B
Script	start_*.bat	A/B


ğŸ§  ConclusÃ£o

O plano aplica tudo o que foi lecionado nas fichas teÃ³ricas e prÃ¡ticas:

Threads e sincronizaÃ§Ã£o (FP3, FP5)

Sockets e comunicaÃ§Ã£o (FP4)

RelÃ³gios e consistÃªncia (FP5, FP6)

EleiÃ§Ã£o e replicaÃ§Ã£o (FP7)

Cada fase introduz um conceito prÃ¡tico do curso, consolidando teoria e implementaÃ§Ã£o realista.
