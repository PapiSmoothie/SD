ğŸ§© Projeto Final â€” Sistemas DistribuÃ­dos 2025/2026
SimulaÃ§Ã£o de TrÃ¡fego Urbano em Java (Processos + Threads + Sockets)

Ambiente: Windows 10/11 Â· IntelliJ IDEA Â· Maven Â· JSON Â· Scripts .bat Â· GitHub
Prazo final: 5 de dezembro de 2025

-------------------------------------------------------------------------

1ï¸âƒ£. Enquadramento TeÃ³rico

Objetivo geral:
Desenvolver um sistema distribuÃ­do em Java que simula o trÃ¡fego urbano de uma cidade, aplicando conceitos de comunicaÃ§Ã£o por sockets, sincronizaÃ§Ã£o entre threads, replicaÃ§Ã£o, polÃ­ticas adaptativas e consistÃªncia.

Base teÃ³rica:

FP1 â€“ IntroduÃ§Ã£o: sistemas distribuÃ­dos, comunicaÃ§Ã£o, escalabilidade;

FP2 â€“ Arquiteturas: cliente-servidor, camadas, comunicaÃ§Ã£o aberta;

FP3 â€“ Processos e Threads: criaÃ§Ã£o, sincronizaÃ§Ã£o e exclusÃ£o mÃºtua;

FP4 â€“ ComunicaÃ§Ã£o: Sockets TCP/UDP e serializaÃ§Ã£o JSON;

FP5 â€“ SincronizaÃ§Ã£o: relÃ³gios lÃ³gicos, Berkeley, Lamport, Ricart & Agrawala;

FP6 â€“ ReplicaÃ§Ã£o e ConsistÃªncia: modelos de atualizaÃ§Ã£o e consistÃªncia eventual;

FP7 â€“ RPC / Token Ring: eleiÃ§Ã£o, coordenaÃ§Ã£o e replicaÃ§Ã£o distribuÃ­da.

-------------------------------------------------------------------------

2ï¸âƒ£. Arquitetura Global
Estrutura em camadas
Camada	FunÃ§Ã£o	Exemplos de classes
AplicaÃ§Ã£o	LÃ³gica de trÃ¡fego, polÃ­ticas, dashboard	CoordinatorServer, CrossingProcess, PolicyManager
Transporte	ComunicaÃ§Ã£o entre processos	LinkIO, ClientHandler
Dados	Modelos e JSONs de configuraÃ§Ã£o	Vehicle, Event, Edge, ConfigLoader
Processos principais

CoordinatorServer â†’ Coordena a simulaÃ§Ã£o, polÃ­ticas e relÃ³gio.

CrossingProcess â†’ Gere cruzamentos, filas e semÃ¡foros.

DashboardHub â†’ Mostra estado e mÃ©tricas.

EntryGenerator â†’ Introduz veÃ­culos na rede.

SinkProcess â†’ Recolhe estatÃ­sticas de fim de percurso.

ComunicaÃ§Ã£o

TCP (bidirecional e confiÃ¡vel).

Mensagens JSON:

{ "type": "Telemetry", "payload": { "crossing": "Cr1", "queue": 3, "avg": 2.5 } }


SerializaÃ§Ã£o via Gson; codificaÃ§Ã£o UTF-8.

3ï¸âƒ£. Guia de Desenvolvimento (Fases 0â€“10)


-------------------------------------------------------------------------

ğŸ§± Fase 0 â€” Alicerces e Contratos

Objetivo: Base comum de dados, mensagens e ficheiros de configuraÃ§Ã£o.
ReferÃªncia: FP2 (Arquiteturas) + FP4 (Mensagens e JSON)

ğŸ”¹ Membro A

Criar pacote sd.traffic.common:

Message, Vehicle, NodeId, Edge, Event

Definir convenÃ§Ãµes de mensagens JSON (Telemetry, VehicleTransfer, PolicyUpdate).

Criar policy_hybrid.json com parÃ¢metros min/max/quotas.

ğŸ”¹ Membro B

Criar estrutura Maven e diretÃ³rios padrÃ£o (src/main/java, src/main/resources).

Implementar ConfigLoader e SimClock.

Criar routes.json e default_config.json.

Testar parsing de JSON (Gson).

ğŸ”¹ Contrato Aâ†”B

JSON base comum com "type" e "payload", UTF-8.
Portas base: 5000 + idProcesso.

ğŸ”¹ AceitaÃ§Ã£o

âœ… mvn clean package sem erros.
âœ… Todos os ficheiros JSON lidos corretamente.

-------------------------------------------------------------------------

ğŸ§  Fase 1 â€” Coordinator e DashboardHub

Objetivo: ComunicaÃ§Ã£o TCP base e centralizaÃ§Ã£o de controlo.
ReferÃªncia: FP4 (Sockets TCP)

ğŸ”¹ Membro A

Implementar CoordinatorServer, ClientHandler, EventLogStore, PolicyManager.

Suportar mensagens:

REGISTER â†’ registar cruzamento.

POLICY_UPDATE â†’ responder com polÃ­tica atual.

EVENT_LOG â†’ registar eventos.

TELEMETRY â†’ imprimir mÃ©tricas e guardar logs.

Gerar events.json com logs.

ğŸ”¹ Membro B

Implementar DashboardHub (TCP Server) para receber e imprimir mÃ©tricas.

Exibir texto em consola (textual agora, Swing nas fases posteriores).

Script: start_dashboard.bat.

ğŸ”¹ Contrato Aâ†”B
{"type": "Telemetry", "crossing": "Cr1", "queue": 4, "avg": 2.5, "lightState": "GREEN"}

ğŸ”¹ AceitaÃ§Ã£o

âœ… Crossings podem registar-se.
âœ… Dashboard recebe e mostra heartbeat.

-------------------------------------------------------------------------

ğŸ”— Fase 2 â€” Crossings e ComunicaÃ§Ã£o TCP

Objetivo: Interligar cruzamentos e simular passagem de veÃ­culos.
ReferÃªncia: FP4 (Sockets) + FP3 (Threads)

ğŸ”¹ Membro A

Criar LinkIO (canal TCP com retry e timeout).

Implementar broadcast de mensagens TELEMETRY recebidas para o DashboardHub (porta 5050).

Criar VehicleTransfer (estrutura de mensagem para passagem de veÃ­culos entre cruzamentos).

Gerir conexÃµes entre cruzamentos.

Manter logs centralizados em events.json.

Script: start_crossingX.bat.

ğŸ”¹ Membro B

Criar CrossingProcess (nÃ³ TCP individual de cada cruzamento):

Recebe veÃ­culo, espera t_sem (tempo de semÃ¡foro), reenvia para o prÃ³ximo.

Implementar ThreadPerConnection para gerir mÃºltiplas ligaÃ§Ãµes.

Log de transaÃ§Ãµes.

Script: start_crossingX.bat

ğŸ”¹ Contrato A â†” B (Crossing â†” Coordinator)

Mensagem de transferÃªncia de veÃ­culo:

{"vehicleId": "V123", "from": "Cr1", "to": "Cr2", "time": 110.0}

ğŸ”¹ CritÃ©rios de AceitaÃ§Ã£o (Fase 2)

âœ… Os Crossings ligam-se ao Coordinator e trocam mensagens sem erros.
âœ… O Coordinator recebe telemetria e difunde-a ao DashboardHub (broadcast).
âœ… O DashboardHub mostra em tempo real o estado dos cruzamentos.
âœ… Todos os sockets funcionam de forma concorrente, sem bloqueios TCP.


Detalhes interessantes a adicionar:

Registo de dashboards
O Coordinator deve reconhecer quando um cliente Ã© o Dashboard (por ex., REGISTER com "role": "dashboard").
Assim, sabe para quem reenviar Telemetry.
ğŸ”¹ AtualizaÃ§Ã£o para fazer agora (Fase 2).

Mensagem de Heartbeat / Ping
Seria Ãºtil (para debug e estabilidade) cada CrossingProcess enviar um "HEARTBEAT" periÃ³dico.
O Coordinator pode registar a Ãºltima atualizaÃ§Ã£o de cada cruzamento.
ğŸ”¹ Opcional nesta fase, mas Ãºtil.

ConfiguraÃ§Ã£o de portas nos scripts
Os .bat devem comeÃ§ar a incluir parÃ¢metros (-Dexec.args) para poder iniciar mÃºltiplos cruzamentos com IDs distintos.
ğŸ”¹ Implementar agora (Fase 2).

Logs mais detalhados no EventLogStore
Registar nÃ£o sÃ³ Telemetry, mas tambÃ©m REGISTER e VehicleTransfer.
ğŸ”¹ Pequena melhoria para fazer agora.
-------------------------------------------------------------------------

ğŸš¦ Fase 3 â€” SemÃ¡foros e Filas

Objetivo: Introduzir sincronizaÃ§Ã£o e controlo de trÃ¡fego.
ReferÃªncia: FP3B (Threads) + FP5 (SincronizaÃ§Ã£o)

ğŸ”¹ Membro A

Criar PhaseController: controla alternÃ¢ncia entre fases (NS/EW).

Implementar exclusÃ£o mÃºtua (mutex global via Coordinator).

Introduzir relÃ³gio lÃ³gico (Lamport clock).

ğŸ”¹ Membro B

Implementar SemaphoreThread e QueueManager.

Cada cruzamento tem:

Thread por direÃ§Ã£o (N, S, E, O).

GestÃ£o de filas (ConcurrentLinkedQueue).

SincronizaÃ§Ã£o com wait() e notifyAll().

Garantir que apenas um sentido estÃ¡ verde.

ğŸ”¹ Contrato Aâ†”B
{"crossing": "Cr1", "semaphore": "N", "state": "GREEN", "queue": 3}

ğŸ”¹ AceitaÃ§Ã£o

âœ… MudanÃ§as de fase sem conflito.
âœ… Fila esvazia corretamente.

-------------------------------------------------------------------------

ğŸ›£ï¸ Fase 4 â€” EntryGenerators e Rotas

Objetivo: Introduzir veÃ­culos na rede com base em Î» (Poisson).
ReferÃªncia: FP4 (ComunicaÃ§Ã£o)

ğŸ”¹ Membro A

Criar EntryGeneratorProcess (thread que envia veÃ­culos periodicamente).

Ligar-se ao Coordinator.

Definir taxa Î» por entrada (E1â€“E3).

ğŸ”¹ Membro B

Criar RouteSelector: lÃª routes.json e define percursos probabilÃ­sticos.

Testar geraÃ§Ã£o paralela com threads independentes.

ğŸ”¹ Contrato Aâ†”B
{"entry": "E1", "vehicleType": "carro", "path": ["E1","Cr1","Cr4","Cr5","S"]}

ğŸ”¹ AceitaÃ§Ã£o

âœ… VeÃ­culos gerados segundo Î».
âœ… Percursos vÃ¡lidos e concluÃ­dos.

-------------------------------------------------------------------------

â±ï¸ Fase 5 â€” DeslocaÃ§Ã£o entre NÃ³s

Objetivo: Gerir tempo simulado e envio ordenado de mensagens.
ReferÃªncia: FP5 (Lamport e Berkeley)

ğŸ”¹ Membro A

Usar SimClock para relÃ³gio global.

Implementar Coordinator como time daemon (Berkeley).

Enviar SEND_TO_NEXT e agendar RECEIVE_FROM_PREV.

ğŸ”¹ Membro B

Receber veÃ­culos e colocÃ¡-los na fila local.

Confirmar atraso correto (t_road * factor).

ğŸ”¹ AceitaÃ§Ã£o

âœ… Tempo entre nÃ³s coerente.
âœ… Eventos ordenados (Lamport clock).

-------------------------------------------------------------------------

ğŸ§® Fase 6 â€” PolÃ­ticas Adaptativas

Objetivo: AdaptaÃ§Ã£o de tempos conforme trÃ¡fego.
ReferÃªncia: FP6 (ReplicaÃ§Ã£o e ConsistÃªncia)

ğŸ”¹ Membro A

PolicyManager â†’ primary replica.

Atualiza tempos verdes/vermelhos conforme filas.

Envia POLICY_UPDATE para cruzamentos.

ğŸ”¹ Membro B

Aplica polÃ­tica localmente e confirma ACK.

Implementa consistÃªncia eventual.

MantÃ©m Ãºltima polÃ­tica ativa em cache.

ğŸ”¹ AceitaÃ§Ã£o

âœ… PolÃ­ticas atualizam-se em tempo real.
âœ… Logs sincronizados.

-------------------------------------------------------------------------

ğŸ” Fase 7 â€” Sink e EstatÃ­sticas

Objetivo: Recolher resultados e calcular mÃ©tricas.
ReferÃªncia: FP6 (ConsistÃªncia eventual)

ğŸ”¹ Membro A

Criar SinkProcess (porta 6300).

Receber veÃ­culos concluÃ­dos e calcular tempos mÃ©dios.

ğŸ”¹ Membro B

Enviar mÃ©tricas periÃ³dicas ao Dashboard.

Criar metrics_summary.json.

ğŸ”¹ AceitaÃ§Ã£o

âœ… EstatÃ­sticas corretas e consistentes.

ğŸ§© Fase 7.5 â€” CoordenaÃ§Ã£o e ConsistÃªncia Replicada

Objetivo: Garantir continuidade apÃ³s falhas.
ReferÃªncia: FP7 (Token Ring, EleiÃ§Ã£o)

ğŸ”¹ Membro A

Implementar ElectionManager (Bully ou Token Ring).

Substituir CoordinatorServer em caso de falha.

ğŸ”¹ Membro B

Implementar ReplicaSync: sincroniza estado dos cruzamentos.

Reintegra cruzamentos desconectados.

ğŸ”¹ AceitaÃ§Ã£o

âœ… Sistema recupera apÃ³s falhas.
âœ… RÃ©plicas atualizadas.

-------------------------------------------------------------------------

ğŸ“Š Fase 8 â€” Dashboard Final

ReferÃªncia: FP2 (Camadas) + FP7 (RPC)

ğŸ”¹ Membro A

Criar API TCP no DashboardHub para histÃ³rico.

ğŸ”¹ Membro B

Interface JavaFX ou consola com mapa 3Ã—3 e grÃ¡ficos.

ExportaÃ§Ã£o CSV e refresh 2 Hz.

ğŸ”¹ AceitaÃ§Ã£o

âœ… AtualizaÃ§Ã£o contÃ­nua e exportaÃ§Ã£o funcional.

-------------------------------------------------------------------------


ğŸ”¬ Fase 9 â€” CenÃ¡rios e PolÃ­ticas

ReferÃªncia: FP1â€“FP6 (Experimentos distribuÃ­dos)

ğŸ”¹ Membro A

Criar ScenarioRunner (executa low/medium/high load).

ğŸ”¹ Membro B

Gerar grÃ¡ficos e scenario_results.json.

-------------------------------------------------------------------------


ğŸ§± Fase 10 â€” Testes e Entrega Final

Objetivo: Garantir estabilidade total e integraÃ§Ã£o completa.

ğŸ”¹ Membro A

Scripts .bat para todos os processos.

Testes de reconexÃ£o e timeouts.

ğŸ”¹ Membro B

Testes de stress e concorrÃªncia.

RelatÃ³rio final e mÃ©tricas.

-------------------------------------------------------------------------


ğŸ”§ Planeamento semanal 


| Semana            | Fases      | Membro A                  | Membro B                      | EntregÃ¡veis                 | Marco/Review           |
| ----------------- | ---------- | ------------------------- | ----------------------------- | --------------------------- | ---------------------- |
| **1 (28â€“1 nov)**  | Fase 0     | Modelos + JSON parsing    | Estrutura Maven + routes.json | Projeto compila             | Code Review JSON       |
| **2 (3â€“8 nov)**   | Fase 1     | Coordinator TCP           | DashboardHub                  | Heartbeats visÃ­veis         | Teste rede Aâ†”B         |
| **3 (10â€“15 nov)** | Fase 2     | LinkIO + sockets          | CrossingProcess               | VeÃ­culos dummy transferidos | IntegraÃ§Ã£o cruzamentos |
| **4 (17â€“22 nov)** | Fase 3     | PhaseController           | Semaphores + QueueManager     | Fases e filas funcionais    | Teste local E2E        |
| **5 (24â€“29 nov)** | Fases 4â€“5  | EntryGenerators + eventos | ReceÃ§Ã£o e deslocaÃ§Ã£o          | VeÃ­culos circulam           | Full path test         |
| **6 (1â€“5 dez)**   | Fases 6â€“10 | PolÃ­ticas + cenÃ¡rios      | Sink + dashboard + relatÃ³rio  | SimulaÃ§Ã£o completa          | RevisÃ£o final          |


âš™ï¸ Riscos e MitigaÃ§Ã£o

Risco	                           MitigaÃ§Ã£o
Falha de coordenador --------	EleiÃ§Ã£o distribuÃ­da
InconsistÃªncia -------- SincronizaÃ§Ã£o eventual
Bloqueios TCP --------	Timeouts e retry
Corridas ----------------	synchronized, wait/notify
DivergÃªncia de polÃ­tica --------	ConsistÃªncia sequencial


âœ… EntregÃ¡veis principais:

Tipo	Ficheiro	ResponsÃ¡vel
CÃ³digo	CoordinatorServer.java	A
CÃ³digo	CrossingProcess.java	B
CÃ³digo	PhaseController.java	A
CÃ³digo	SemaphoreThread.java	B
CÃ³digo	DashboardHub.java	B
Config	policy_*.json, default_config.json	A/B
Log	events.json, metrics_summary.json	A/B
Script	start_*.bat	A/B


ğŸ§  ConclusÃ£o

O plano aplica tudo o que foi lecionado nas fichas teÃ³ricas e prÃ¡ticas:

Threads e sincronizaÃ§Ã£o (FP3, FP5)

Sockets e comunicaÃ§Ã£o (FP4)

RelÃ³gios e consistÃªncia (FP5, FP6)

EleiÃ§Ã£o e replicaÃ§Ã£o (FP7)

Cada fase introduz um conceito prÃ¡tico do curso, consolidando teoria e implementaÃ§Ã£o realista.
